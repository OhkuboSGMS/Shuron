# 準備 {#preparation}
本章では,本論文を読む上で必要となる予備知識について述べる.
[@sec:aboutLevel]では本論文で使用する用語であるレベルについて,
[@sec:pcg]ではレベルを含むコンテンツ一般の生成法であるProcedural Content Generationについて,
<!---
[@sec:gan]では機械学習を使用したレベル生成の一例としてGenerative Adversarial Networkについて,
--->
[@sec:smm2]では今回使用するゲーム環境であるスーパーマリオメーカー2について,
[@sec:numpy]では本実装に用いるNumpyについて,
[@sec:pytorch]ではレベル生成のための深層学習に使用したフレームワークであるpytorchについて,
述べる.

## レベルとは {#sec:aboutLevel}
レベルはゲームの難易度を表現する用語として一般的に使用されているが,
それ以外にゲームのコース,ステージ,エリアといった用語と同じ意味を表現する場合もある.

同分野の論文において,レベルは後者の意味で使用されているため,
本論文でも同様の表現として使用する.
ゲームにおけるレベルとは,ゲーム上の
オブジェクト,敵,地形など配置や性質を表現したものである.


## Procedural Content Generation {#sec:pcg}

 Procedural Content Generation(PCG)はアルゴリズムに従って自動的にコンテンツを生成する分野である.
生成されるコンテンツは音楽,グラフィック,ルール,シナリオなどを対象とする.

本節ではPCGで用いられる代表的な手法について説明する.

### 擬似乱数による生成
擬似乱数による生成はPCG初期において使われていた手法である.
この手法ではコンテンツの生成の際のコンテンツの色,角度,太さ,長さといった
パラメータの選択をランダムに行う.

この手法は都市生成[@citygen]やマインクラフト[@minecraft ; @minecraft-noise]の
ワールド生成などに使用されている.


### 検索ベースによる生成
検索ベースによる生成は生成と生成されたコンテンツテストを行う.
検索ベースを満たす手法の条件としてTogeliusら[@search-base]は以下の
条件を上げている

* テスト関数は生成されたコンテンツが合格か不合格かだけを判定するだけではなく
そのコンテンツの数値による評価を行う.

* コンテンツの生成はテスト関数の評価値に依存する.生成は
よりテスト関数のより高い評価を得るようにする.


### Procedural Content Generation for Machine Learning

これまでに紹介した手法は生成のためのアルゴリズム,パラメータ,ルールセットに
設計者の事前知識による特徴づけがされるため汎用性の面で問題が存在する.
Procedural Content Generation for Machine Learning(以下PCGML)は
画像や文章,レベルといった既存のデータから特徴を学習による生成を目的としている.

PCGMLの手法としてGenerative Adversarial Networksを用いた手法を紹介する.

#### Generative Adversarial Network {#sec:gan}
Generative Adversarial Networks(以下GAN)はGoodFellow[@GAN]らによって提案された
生成モデルである.

GANではDiscriminator(判別器)とGenerator(生成器)の二つのネットワーク
を競い合わせて学習を行う.

次にそれぞれのネットワークの役割について説明する

##### Generator

 Generatorはある潜在変数$z$を入力とした時に$z$に基づいた出力を返すネットワークである.
 Generatorの出力がGANにおける学習後の出力となる.
 
##### Discriminator
 Discriminatorはあるデータを入力としてその入力が本物か偽物かを判定するネットワークである.
 画像を入力とした場合その画像が本物か偽物かを判定する.
 実際の判定では真,偽の2値ではなく0から1の間の値で出力される.
 
 真の入力は事前に用意したデータセットであり,
 偽の入力はGeneratorが出力を使用する.

##### GANの学習
Generatorの目標はDiscriminatorを騙すことにある.
つまりGeneratorが出力するデータをDiscriminatorによる判定結果が
よりデータが真であると判定するよう学習する必要がある.

一方でDiscriminatorは本物のデータとGeneratorが生成した偽物のデータを間違わないように
判別できるよう学習する必要がある.

この両者の学習の繰り返しによってGeneratorが出力するデータが
より本物に近くなるよう学習していくというものである.

この学習のサイクルを表した図を[@fig:gan]に示す.

![GANのアーキテクチャ図](img/GAN.png){#fig:gan}

このGANを用いた生成モデルは多くの分野で応用されており
特に画像ドメインにおいては超解像[@BigGan;@Pro]やスタイル変換[@Cartoon;@Style]
などで研究されている.

画像以外においても文章生成[@SeqGan]や音楽生成[@MidiGan]などに使用されている.

## スーパーマリオメーカー２ {#sec:smm2}

スーパーマリオメーカー2(以下smm2)は,任天堂より2019年6月28日に発売された Nintendo Switch
用ゲームソフトである.
ジャンルは2Dアクションゲーム,レベルエディタである.
2015年に9月10日に発売されたWii U用ゲームソフトスーパーマリオメーカーに続くシリーズ2作目である.
売り上げは2019年9月末時点で全世界393万本[@smm2-sales]であり,多くのユーザがプレイしている.

スーパーマリオメーカーシリーズは2Dアクションゲームであるスーパーマリオブラザーズを
ベースにしたゲーム兼エディタで,プレイヤはステージをつくる,あそぶことができる.
スーパーマリオブラザーズのゲームの目的は,ステージを敵や障害物に倒されずに
進み,ゴールに制限時間にたどり着くことである.
プレイヤが出来るアクションはジャンプ,アイテムの効果を使う,ギミックを使うことが出来る.

### つくる

[@fig:smm2-editor]にステージ編集画面を示す.

![smm2のステージ編集画面](img/stageEditor.jpeg){#fig:smm2-editor}

\

プレイヤは2Dのスーパーマリオのステージに自由に配置ができる.
配置できるオブジェクトのタイプは4種類に分けられる.

* 地形:
プレイヤが移動する地面やブロック

* アイテム:
手に入れることでプレイヤの状態が変化する

* 敵:
プレイヤに対して攻撃を仕掛けてくる

* しかけ:
プレイヤが触れると攻撃を受ける,定期的にアイテムを出現させるなどのギミック.

オブジェクトは全部で100種類以上あり,さらにオブジェクト
同士の合成や状態の変化を設定できる.

それ以外にもステージの見た目を設定できるシーンスキン,
ベースとなるスーパーマリオシリーズを設定できるゲームスキン,
ゲームのクリア条件の設定などがある.


作成したステージは,オンライン上に投稿することができる.
投稿するステージは
作成者であるプレイヤが実際にプレイしてゲームクリアができないと投稿することができない.

### あそぶ

プレイヤは他のユーザが投稿したステージを遊ぶことが出来る.
遊んだプレイヤはそのステージについて評価することが出来る.

ステージはランキング形式やステージの性質や人気順で検索することが出来る.

ゲームプレイ時に1人だけではなくオンラインで最大4人で1つのステージを遊ぶことが出来る.

### BCDファイル

スーパーマリオメーカー2のレベル情報が格納されているデータフォーマットは
BCDファイルと呼ばれ,1ファイルに1ステージのレベル情報が保存されている.

BCDファイルはSMM2において敵の位置や属性,ブロックの大きさ,位置,方向などの
情報がオブジェクトごとに書き込まれている.

このBCDファイルを読み込むことによってレベル情報を取得することができる.

#### ファイル構造

ファイル構造について述べる.
[@fig:bcd_structure]にBCDファイルの構造を示す.
[@fig:bcd_structure]のサイズは16進数で各セクションのバイト数を示している.

![BCDファイルの構造](img/bcd.png){#fig:bcd_structure}

\

BCDファイルは4つのセクションに分かれている.
次にそれぞれのセクションについて説明する.

#### レベルヘッダ
レベルヘッダはSMM2のレベルの副次的な情報が保存されている.

ゲームのコース（ステージ）内には存在しない制限時間やゲームのテーマなどが含まれている.

#### コースデータ

レベルヘッダはSMM2のオブジェクトに関する副次的な情報が保存されている.
オブジェクトの個数や特定のオブジェクトの個数などが保存されている.

#### オブジェクトデータ
オブジェクトデータは実際にコース（ステージ）内に配置されるオブジェクトの情報が保存されている.
オブジェクトの数は可変であるため,データ量はオブジェクトの個数*オブジェクトの固定サイズである.

オブジェクトは[@tbl:object_struct]のようにデータが表現される.

オブジェクトあたりのデータサイズは0x20Byteである.

|label| Offset | Size | Description |
|-----|----- |------|------|
|X| 0x0    | 0x4  | X座標 |
|Y| 0x4    | 0x4  | Y座標 |
|W| 0xA    | 0x1  | オブジェクトの幅 |
|H| 0xB    | 0x1  | オブジェクトの高さ |
|Flag| 0xC    | 0x4  | オブジェクトの状態 |
|ID| 0x18   | 0x2  |オブジェクトの種類 |
:オブジェクトデータ構造 {#tbl:object_struct}



#### そのほか
オブジェクトデータ以降のデータを一括してそのほかとした.
これらのデータはレベル上に配置されるオブジェクトのうち,ある特定のオブジェクトに関する
追加の情報を保存している.
ブロックをプレイヤが押したときの動作やある範囲に侵入したときの効果音などが
含まれている.

また,特別にタイルデータと呼ばれるものが存在し,このデータはゲーム内の地面を
表す$Ground$が配置される位置についてのデータである.
タイルは[@tbl:tile]のようにデータが表現される.

|Label| Offset | Size | Description |
|----|--------|------|------------- |
|TileX| 0x0    | 0x1  | タイルのX座標 |
|TileY| 0x1    | 0x1  | タイルのY座標 |
:タイル表 {#tbl:tile}

全てのタイルのサイズは1x1(width,height) で固定されている.

## NumPy {#sec:numpy}

NumPyはオープンソースのPython用化学計算パッケージである.化学計算に必要なN次元配列オブジェクトやブロードキャスティング機能,
線形代数,フーリエ変換,乱数機能などを便利なパッケージとして提供している.NumPyはBCDライセンスで提供されており学術用途だけではなく
商用目的でも使用できる.NumPyは様々なアルゴリズムや計算パッケージのデータ型としても採用されており幅広い利用探されている.
NumPyの代表的な機能についていくつか取り上げる.

### 多様な型のサポート

NumPyがサポートしている型について[@tbl:numpy_type]に示す.

| type        | 説明|
|--------------|------|
| bool       | バイトとして保存される真偽値  |
| int8    | 整数(-127~127) |
| int16      | 整数(-32768~32767) |
| int32　　　　　 | 整数（-2147483648~2147483647）  |
| int64         | 整数（-9223372036854775808~9223372036854775807)  |
| uint8         | 符号なし整数（0〜255）   |
| uint16         | 符号なし整数（0〜65535）   |
| uint32         | 符号なし整数（0〜4294967295）  |
| uint64         | 符号なし整数（0から18446744073709551615）   |
| float16         |半精度浮動小数点数 指数:5bit 仮数:10bit  |
| float32         |単精度浮動小数点数  指数:8bit 仮数:23bit |
| float64         | 倍精度浮動小数点数  指数:11bit 仮数:52bit   |
| complex64         | 実数部と虚数部のfloat32で構成される複素数   |
| complex128         | 実数部と虚数部のfloat64で構成される複素数   |
:キャプション {#tbl:numpy_type}

NumPyのサポートするデータ型
またデータ型同士の変換も容易に行うことができる.
 
### ブロードキャスト

ブロードキャストは異なる形状を持つ配列間での計算を行うための仕組みである.
ブロードキャストは計算時にサイズが小さい配列を大きい配列に合わせる形に変形して
計算を行う.

[@lst:broadcast]に実際のコードを示す　

~~~~{caption="BroadCast" label=lst:broadcast}
>>> a = np.array([1.0, 2.0, 3.0])
>>> b = 2.0
>>> a * b
array([ 2.,  4.,  6.])
~~~~

[@lst:broadcast]ではaとbの掛け算の際にbのサイズがaのサイズに
拡大されて計算がされている.

このようにブロードキャストは形状の違う配列同士での計算も可能にする.

### NPYフォーマット
 npyフォーマットはnumpy配列のためのバイナリシリアライゼーションである.
 npyではnumpyで表現される全てのデータ形式,データ型をサポートしている.
 npyはzip形式によるファイルのデータ容量の圧縮ファイルであるnpzに対応している.
 
## PyTorch {#sec:pytorch}
PyTorch[@pytorch]はオープンソースの深層学習用のPythonパッケージである.
PyTorchの特徴として以下の機能が挙げられる.

* GPUによる高速なテンソル計算
* 自動微分機能による深層学習

計算を行う際,PyTorchはGPUによる計算とCPUによる計算のどちらにも対応しており
開発者はどのデバイスで計算するかを選択することができる.

NumPyと同様にデータ型を選ぶことができ,そのデータを保持するための機構は$tensor$と呼ばれる.
$tensor$はNumPyのデータ型とメモリレベルで型を共有しており変換が可能である.
変換は双方向で行うことができる.
さらに$tensor$はGPUとCPUの間では別のメモリ上に展開され,GPU上の$tensor$を$CUDAtensor$と呼び,
GPUとCPU間で変換を行う必要がある.

自動微分機能によってニューラルネットワークを構築する際に学習の際の
誤差逆伝搬を自動的に行ってくれる.このためネットワーク設計者は順伝搬の方向だけを設計するだけで良い.

PyTorchは初期はFaceBookによって開発されているがオープンソースプロジェクトであり
コミュニティによって開発されている.ライセンスはBCDライセンスである.
